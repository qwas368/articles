# [Kleisli Categories](https://bartoszmilewski.com/2014/12/23/kleisli-categories/)

> 在上一節的Category Theory for Programmers，[Categories Great and Small](https://github.com/qwas368/articles/blob/master/Category%20Theory%20for%20Programmers/1.3%20Categories%20Great%20and%20Small.md)，我舉了一些簡單的範疇範例。在本期中，我們將介紹一個更高級的範例。如果你是這個系列的新讀者，這裡是[目錄](https://github.com/qwas368/articles/blob/master/Category%20Theory%20for%20Programmers/Table%20of%20Contents.md)

# Log組合 Composition of Logs 

您已經了解瞭如何將型別和純函數建模為範疇。我也提及一種在範疇中對副作用或非純函數建模的方法。讓我們看一個這樣的例子：記錄或追蹤執行的函數。用命令式語言可以通過更改某些全域狀態來實現某些功能，例如：
```c++
string logger;

bool negate(bool b) {
     logger += "Not so! ";
     return !b;
}
```

你知道這不是一個純函數，因為它會生成Log。此函數有副作用。

在現代編程中，我們嘗試盡可能遠離全域可變狀態 — 只是因為並發的複雜性。且你永遠不會將這樣的程式碼放在函式庫中。

對我們來說幸運，我們是可以使此函數純淨。您只需要顯式地傳入和傳出日誌即可。為此，添加一個字串參數，然後將常規輸出和更新完紀錄的字串配成一對：
```c++
pair<bool, string> negate(bool b, string logger) {
     return make_pair(!b, logger + "Not so! ");
}
```

此函數是純函數，沒有副作用，每次使用相同的參數調用時都會返回相同的一對結果，並且可以在必要時進行記憶下來。但是，考慮到日誌的累積性，你必須記住可能呼叫此函數的所有歷史記錄。

```c++
negate(true, "It was the best of times. ");
```
和
```c++
negate(true, "It was the worst of times. ");
```
等等

這對於函數庫來說也不是一個很好的界面。呼叫者可以自由的忽略回傳的字串，所以不是個負擔。但是他們被迫傳遞一個字串作為輸入，這很不方便。

有沒有一種方法可以減少干擾性地做同一件事？有沒有辦法分離關注點？這個簡單的例子中，函數主要的目標 `negate` 是將一個布林值轉化成另一個。日誌才是第二目標。當然，所記錄的訊息是特定於該函式的，但是將訊息聚合為一個連續的日誌的工作是分離關注。我們仍然希望函數產生一個字串，但我們希望減輕產生日誌的負擔。因此，這是折衷解決方案：
```c++
pair<bool, string> negate(bool b) {
     return make_pair(!b, "Not so! ");
}
```
這個想法是在函數調用之間聚合日誌。

要了解如何做到這一點，讓我們轉到一個更現實的例子。從字串到字串，我們有一個函數可以將小寫字串變為大寫：

```c++
string toUpper(string s) {
    string result;
    int (*toupperp)(int) = &toupper; // toupper is overloaded
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return result;
}
```
另一個函數將字串拆分為字串列，並在空格處將其切開：
```c++
vector<string> toWords(string s) {
    return words(s);
}
```
實際工作通過輔助函數 `words`完成：
```c++
vector<string> words(string s) {
    vector<string> result{""};
    for (auto i = begin(s); i != end(s); ++i)
    {
        if (isspace(*i))
            result.push_back("");
        else
            result.back() += *i;
    }
    return result;
}
```
我們想要修改函數`toUpper`和`toWords`，以便它們在其常規返回值之上搭載訊息字串。
![image](https://i.imgur.com/epC2bNZ.png)
我們將「修飾」這些函數的返回值。讓我們以一種通用的方式來定義一個模板 `Writer`，該模板封裝一對結果，其第一個元件是任意型別 `A` ，第二個元件是一個字串：
```c++
template<class A>
using Writer = pair<A, string>;
```
以下是修飾的函數：
```c++
Writer<string> toUpper(string s) {
    string result;
    int (*toupperp)(int) = &toupper;
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return make_pair(result, "toUpper ");
}

Writer<vector<string>> toWords(string s) {
    return make_pair(words(s), "toWords ");
}
```

我們希望將這兩個函數組成另一個修飾函數，該函數將字串大寫並將其拆分為單字，同時生成這些動作的日誌。我們可以這樣做：

```c++
Writer<vector<string>> process(string s) {
    auto p1 = toUpper(s);
    auto p2 = toWords(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
```
我們已經實現了我們的目標：日誌的聚合不再是各個功能的關注點。他們產生自己的訊息，然後在外部將其連接成更大的日誌。
現在想像一下以這種風格編寫整個程序。這是重複編程的噩夢，容易出錯的代碼。但是我們是軟體工程是。我們知道如何處理重複的代碼：我們將其抽象化！但是，這不是要你用磨坊碾碎她-我們必須抽象函數組合本身。但是組合是範疇論的本質，因此在編寫更多代碼之前，讓我們從範疇的角度分析問題。

## The Writer Category
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTkyMTMxMjE5OSw4MDgxMjYwNjAsLTE0MD
g0ODUzNDgsLTE0NTUwMzc4NTQsLTE5MjkwOTMwMiwyNTA4NDky
NTQsLTgxOTM5NDI5NF19
-->