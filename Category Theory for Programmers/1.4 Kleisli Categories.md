# [Kleisli Categories](https://bartoszmilewski.com/2014/12/23/kleisli-categories/)

> 在上一節的Category Theory for Programmers，[Categories Great and Small](https://github.com/qwas368/articles/blob/master/Category%20Theory%20for%20Programmers/1.3%20Categories%20Great%20and%20Small.md)，我舉了一些簡單的範疇範例。在本期中，我們將介紹一個更高級的範例。如果你是這個系列的新讀者，這裡是[目錄](https://github.com/qwas368/articles/blob/master/Category%20Theory%20for%20Programmers/Table%20of%20Contents.md)

# Composition of Logs

您已經了解瞭如何將型別和純函數建模為範疇。我也提及一種在範疇中對副作用或非純函數建模的方法。讓我們看一個這樣的例子：記錄或追蹤執行的函數。用命令式語言可以通過更改某些全域狀態來實現某些功能，例如：
```c++
string logger;

bool negate(bool b) {
     logger += "Not so! ";
     return !b;
}
```

你知道這不是一個純函數，因為它會生成日誌。此函數有副作用。

在現代編程中，我們嘗試盡可能遠離全域可變狀態 — 只是因為並發的複雜性。且你永遠不會將這樣的程式碼放在函式庫中。

對我們來說幸運，我們是可以使此函是純淨。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTI1NjkxNDkzMiwtMTkyOTA5MzAyLDI1MD
g0OTI1NCwtODE5Mzk0Mjk0XX0=
-->